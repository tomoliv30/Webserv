"location@@"
""
"location@@"
"location@@"
"location@@"


it = map.find("listen") != map.end();
it->second = 5000;


map 
=NOTES=
Webserv
This is when you finally understand why a url starts
with HTTP

Summary: This project is here to make you write your own HTTP server. You will
follow the real HTTP RFC and you will be able to test it with a real browser. HTTP is
one of the most used protocol on internet. Knowing its arcane will be useful, even if you
won’t be working on a website.

Introduction
The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems.
HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access, for
example by a mouse click or by tapping the screen in a web browser.
HTTP was developed to facilitate hypertext and the World Wide Web.
The primary function of a web server is to store, process and deliver web pages to clients.
The communication between client and server takes place using the Hypertext Transfer
Protocol (HTTP).
Pages delivered are most frequently HTML documents, which may include images,
style sheets and scripts in addition to the text content.
Multiple web servers may be used for a high traffic website.
A user agent, commonly a web browser or web crawler, initiates communication by
making a request for a specific resource using HTTP and the server responds with the
content of that resource or an error message if unable to do so. The resource is typically a
real file on the server’s secondary storage, but this is not necessarily the case and depends
on how the web server is implemented.
While the primary function is to serve content, a full implementation of HTTP also
includes ways of receiving content from clients. This feature is used for submitting web
forms, including uploading of files.


malloc, free, write, open, read, close, mkdir,
rmdir, unlink, fork, wait, waitpid, wait3, wait4,
signal, kill, exit, getcwd, chdir, stat, lstat,
fstat, lseek, opendir, readdir, closedir, execve,
127.0.0.1dup, dup2, pipe, strerror, errno, gettimeofday,
strptime, strftime, usleep, select, socket, accept,
listen, send, recv, bind, connect, inet_addr,
setsockopt, getsockname, fcntl

Write a HTTP server in C++ 98

• You must write a HTTP server in C++ 98
• The C++ standard must be C++ 98. Your project must compile with it.
• It must be conditionnal compliant with the rfc 7230 to 7235 (http 1.1) but you need
to implement only the following headers

◦ Accept-Charsets
◦ Accept-Language
◦ Allow
◦ Authorization
◦ Content-Language
◦ Content-Length
◦ Content-Location
◦ Content-Type
◦ Date
◦ Host
◦ Last-Modified
◦ Location
◦ Referer
◦ Retry-After
◦ Server
◦ Transfer-Encoding
◦ User-Agent
◦ WWW-Authenticate


• You can implement all the headers if you want to
• We will consider that nginx is HTTP 1.1 compliant and may be use to compare
headers and answer behaviors
• It must be non blocking and use only 1 select for all the IO between the client and
the server (listens includes).
• Select should check read and write at the same time.
• Your server should never block and client should be bounce properly if necessary
• You should never do a read operation or a write operation without going through
select
• Checking the value of errno is strictly forbidden after a read or a write operation
• A request to your server should never hang forever
• You server should have default error pages if none are provided
• Your program should not leak and should never crash, (even when out of memory
if all the initialisation is done)
• You can’t use fork for something else than CGI (like php or perl or ruby etc...)
• You can include and use everything in "iostream" "string" "vector" "list" "queue"
"stack" "map" "algorithm"
• Your program should have a config file in argument or use a default path

We’ve let you use fcntl because mac os X doesn’t implement write the
same way as other unix OS.
You must use non-blocking FD to have a result similar to other OS.


Because you are using non-blocking FD, you could use read/recv or
write/send functions without select and your server would be not
blocking.
Again trying to read/recv or write/send in any FD without going
through a select will give you a mark equal to 0 and the end of the
evaluation.

You can only use fcntl as follow:
Any other flags is forbidden

fcntl(fd, F_SETFL, O_NONBLOCK);

• In this config file we should be able to:

You should inspire yourself from the "server" part of nginx
configuration file

◦ choose the port and host of each "server"
◦ setup the server_names or not
◦ The first server for a host:port will be the default for this host:port (meaning
it will answer to all request that doesn’t belong to an other server)
◦ setup default error pages
◦ limit client body size
◦ setup routes with one or multiple of the following rules/configuration (routes
wont be using regexp): (location)
	∗ define a list of accepted HTTP Methods for the route
	∗ define a directory or a file from where the file should be search (for example
	if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is
	/tmp/www/pouic/toto/pouet)
	∗ turn on or off directory listing
	∗ default file to answer if the request is a directory
	
	∗ execute CGI based on certain file extension (for example .php)
		· You wonder what a CGI is go? https://en.wikipedia.org/wiki/Common_Gateway_In
		· Because you wont call the cgi directly use the full path as PATH_INFO
		· Just remember that for `chunked request`, your server need to unchunked it and the CGI will expect EOF as end of the body.
		· Same things for the output of the CGI. if no content_length is returned
		from the CGI, EOF will mean the end of the returned data.
		· Your program should set the following Meta-Variables
		AUTH_TYPE
		CONTENT_LENGTH
		CONTENT_TYPE
		GATEWAY_INTERFACE
		PATH_INFO
		PATH_TRANSLATED
		QUERY_STRING
		REMOTE_ADDR
		REMOTE_IDENT
		REMOTE_USER
		REQUEST_METHOD
		REQUEST_URI
		SCRIPT_NAME
		SERVER_NAME
		SERVER_PORT
		SERVER_PROTOCOL
		SERVER_SOFTWARE
		· Your program should call the cgi with the file requested as first argument
		· the cgi should be run in the correct directory for relativ path file access
		· your server should work with php-cgi
	∗ make the route able to accept uploaded files and configure where it should
	be saved

You should provide some configuration files for evaluation
If you’ve got a question about one behavior, you should compare
your program behavior with nginx. For example check how server_name
works...

Please read the RFC and do some test with telnet and nginx before
starting this project.

We’ve shared with you a small tester.
Do not try evaluation if this tester fails.

The important things is resilience.
It will be stress tested.



Your server should never die.

Do not test with only one program, write your own test with a
language quick to write/use, like python or golang or javascript
or rails etc... you can even do your test in c or c++
=NOTES=

RFC 7230
https://tools.ietf.org/html/rfc7230


HTTP client is aprogram that establishes a connection to a server for the purpose ofsending one or more HTTP requests.  

*An HTTP "server"* is a program that accepts connections in order to service HTTP requests by sendingHTTP responses.

*User agent*  refers to any of the various client programs that initiate a request.

*Web Spiders*


*Uri* Uniform Resource Identifier standard to indicate the target resource and relationships between resources.

messages are passed in a format similar to IMF, and Multipurpose Internet Mail extensions




Http

 The following example illustrates a typical message exchange for a
   GET request (Section 4.3.1 of [RFC7231]) on the URI
   "http://www.example.com/hello.txt":

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: "34aa387-d-1568eb00"
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.
	 



HTTP request: request message, 
beginning with 
	- a request-line that includes a method, URI, and protocol version
	- header fields containing 
			- request modifiers, 
			- client information, and 
			- representation metadata (Section 3.2),
	- an empty line to indicate the end of the header section 
	- a message body containing the _payload_ _body_ if any

  A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a 
   -	status line that includes the protocol version, a success or error code, and textual reason
   phrase (Section 3.1.2), 
   - possibly followed by header fields containing server information, resource metadata, and representation metadata
   (Section 3.2), 
   - an empty line to indicate the end of the header
   section, 
   - and finally a message body containing the payload body (if
   any, Section 3.3)


=HTTP intermediary:=

Three types:
	- Proxy
	- Getaway
	- Tunnel
	
They can switch behavior.
Upstream/downstream directional requirements.
	all messages flow from upstream to downstream.
Inbound/outbound = towards the server/toward the user agent

Proxy:
	message forwarding agent selected by the client to receive requests for some types of absolute URI and attempts
	to satisfy those requests via translation through the HTTP interface.
	
Gateway(reverse proxy)
	acts as an origin server for the outbound connection but translates received requests and forwards
	them inbound to another server(s)
	
Tunnnel: blind relay between two connecftions without changing the messages.
They extend a virtual connection through an intermediary such as when TLS is used to establish a confidential communication through a shared firewall proxy.

They introduce flaws because at a protocol level they are indistinguishable from a MITM attack.
Interception proxy(transparent proxy) != http proxy

Stateless protocol = each request message can be understood in isolation.
A server MUST NOT assume that two requests on the same connection are from the same user agent.

=Caches=

A "cache" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion.
   A cache stores cacheable responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests.  Any client or server MAY employ a cache, though a cache
   cannot be used by a server while it is acting as a tunnel.
A response is cacheable is it is allowed. There might be additional constraints.


ABNF rules.
Conformace includes syntax and semantics of protocol elements.

Http does not define specific error handling mechanisms except when they have a direct impact on security.


The origin server for an "http" URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   ([RFC3986], Section 3.2.2).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in 
   

=Parsing a http message=
MAPS for headers
USASCII

A sender MUST NOT send whitespace between the start-line and the
   first header field.  A recipient that receives whitespace between the
   start-line and the first header field MUST either reject the message
   as invalid or consume each whitespace-preceded line without further
   processing of it (i.e., ignore the entire line, along with any
   subsequent lines preceded by whitespace, until a properly formed
   header field is received or the header section is terminated).

   The presence of such whitespace in a request might be an attempt to
   trick a server into ignoring that field or processing the line after
   it as a new request, either of which might result in a security
   vulnerability if other implementations within the request chain
   interpret the same message differently.  Likewise, the presence of
   such whitespace in a response might be ignored by some clients or
   cause others to cease parsing.
   
Start line
Request line

Recipients of an invalid request-line SHOULD respond with either a
   400 (Bad Request) error or a 301 (Moved Permanently) redirect with
   the request-target properly encoded.
   
   
     It is RECOMMENDED that all HTTP senders and recipients
   support, at a minimum, request-line lengths of 8000 octets.







=URI (uniform resource identifiers)=

 Each protocol element in HTTP that allows a URI reference will
   indicate in its ABNF production whether the element allows any form
   of reference (URI-reference), only a URI in absolute form
   (absolute-URI), only the path and optional query components, or some
   combination of the above.  Unless otherwise indicated, URI references
   are parsed relative to the effective request URI 
   
    The "http" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([RFC0793]) connections on a given port.
   
   


=Parsing a http message=
MAPS for headers
USASCII

A sender MUST NOT send whitespace between the start-line and the
   first header field.  A recipient that receives whitespace between the
   start-line and the first header field MUST either reject the message
   as invalid or consume each whitespace-preceded line without further
   processing of it (i.e., ignore the entire line, along with any
   subsequent lines preceded by whitespace, until a properly formed
   header field is received or the header section is terminated).

   The presence of such whitespace in a request might be an attempt to
   trick a server into ignoring that field or processing the line after
   it as a new request, either of which might result in a security
   vulnerability if other implementations within the request chain
   interpret the same message differently.  Likewise, the presence of
   such whitespace in a response might be ignored by some clients or
   cause others to cease parsing.
   
Start line
Request line

Recipients of an invalid request-line SHOULD respond with either a
   400 (Bad Request) error or a 301 (Moved Permanently) redirect with
   the request-target properly encoded.
   
   
     It is RECOMMENDED that all HTTP senders and recipients
   support, at a minimum, request-line lengths of 8000 octets.
   
	=Field Order=
	
	A server MUST NOT
   apply a request to the target resource until the entire request
   header section is received, since later header fields might include
   conditionals, authentication credentials, or deliberately misleading
   duplicate header fields that would impact request processing.
   
    A recipient MAY combine multiple header fields with the same field
   name into one "field-name: field-value" pair, without changing the
   semantics of the message, by appending each subsequent field value to
   the combined field value in order, separated by a comma.  The order
   in which header fields with the same field name are received is
   therefore significant to the interpretation of the combined field
   value; a proxy MUST NOT change the order of these field values when
   forwarding a message.

Je pige pas.

=whitespaces=
A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element.
   
   =field parsing=
   
     No whitespace is allowed between the header field-name and colon.  In
   the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.  A
   server MUST reject any received request message that contains
   whitespace between a header field-name and colon with a response code
   of 400 (Bad Request).  A proxy MUST remove any such whitespace from a
   response message before forwarding the message downstream.
   
     No whitespace is allowed between the header field-name and colon.  In
   the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.  A
   server MUST reject any received request message that contains
   whitespace between a header field-name and colon with a response code
   of 400 (Bad Request).  A proxy MUST remove any such whitespace from a
   response message before forwarding the message downstream.
   
     No whitespace is allowed between the header field-name and colon.  In
   the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.  A
   server MUST reject any received request message that contains
   whitespace between a header field-name and colon with a response code
   of 400 (Bad Request).  A proxy MUST remove any such whitespace from a
   response message before forwarding the message downstream.
  
   A server that receives an obs-fold in a request message that is not
   within a message/http container MUST either reject the message by
   sending a 400 (Bad Request), preferably with a representation
   explaining that obsolete line folding is unacceptable, or replace
   each received obs-fold with one or mo
   
     A server that receives a request header field, or set of fields,
   larger than it wishes to process MUST respond with an appropriate 4xx
   (Client Error) status code.  Ignoring such header fields would
   increase the server's vulnerability to request smuggling attacks
   
=Fiel Value Components=

Delimiters are chosen
   from the set of US-ASCII visual characters not allowed in a token
   (DQUOTE and "(),/:;<=>?@[\]{}").
   
      Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses.  Comments are only allowed in
   fields containing "comment" as part of their field value definition.
   
   The backslash octet ("\") can be used as a single-octet quoting
   mechanism within quoted-string and comment constructs.  Recipients
   that process the value of a quoted-string MUST handle a quoted-pair
   as if it were replaced by the octet following the backslash.
   
    A sender SHOULD NOT generate a quoted-pair in a quoted-string except
   where necessary to quote DQUOTE and backslash octets occurring within
   that string.  A sender SHOULD NOT generate a quoted-pair in a comment
   except where necessary to quote parentheses ["(" and ")"] and
   backslash octets occurring within that comment.
   
   Je pige pas.

=Message Body=


The presence of a message body in a request is signaled by a
   Content-Length or Transfer-Encoding header field.  Request message
   framing is independent of method semantics, even if the method does
   not define any use for a message body.
   
Responses to the HEAD request method never include a message body because the associated
response header fields (e.g., Transfer-Encoding, Content-Length,
etc.), if present, indicate only what their values would have been if
the request method had been GET (Section 4.3.1 of [RFC7231]). 2xx
(Successful) responses to a CONNECT request method (Section 4.3.6 of
[RFC7231]) switch to tunnel mode instead of having a message body.
All 1xx (Informational), 204 (No Content), and 304 (Not Modified)
responses do not include a message body.  All other responses do
include a message body, although the body might be of zero length

=Transfer Encoding=

 A recipient MUST be able to parse the chunked transfer coding
   (Section 4.1) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.
   
   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request 
   
    A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).
   
=Content-length=


  When a message does not have a Transfer-Encoding header field, a
   Content-Length header field can provide the anticipated size, as a
   decimal number of octets, for a potential payload body.  For messages
   that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the
   body (and message) ends. 
   
     When a message does not have a Transfer-Encoding header field, a
   Content-Length header field can provide the anticipated size, as a
   decimal number of octets, for a potential payload body.  For messages
   that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the
   body (and message) ends. 
   
    A server MAY send a Content-Length header field in a response to a
   HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send
   Content-Length in such a response unless its field-value equals the
   decimal number of octets that would have been sent in the payload
   body of a response if the same request had used the GET method.

A server MUST NOT send a Content-Length header field in any response
   with a status code of 1xx (Informational) or 204 (No Content).  A
   server MUST NOT send a Content-Length header field in any 2xx
   (Successful) response to a CONNECT reques
   
   
   Aside from the cases defined above, in the absence of
   Transfer-Encoding, an origin server SHOULD send a Content-Length
   header field when the payload body size is known prior to sending the
   complete header section.  This will allow downstream recipients to
   measure transfer progress, know when a received message is complete,
   and potentially reuse the connection for additional requests.

Aside from the cases defined above, in the absence of
   Transfer-Encoding, an origin server SHOULD send a Content-Length
   header field when the payload body size is known prior to sending the
   complete header section.  This will allow downstream recipients to
   measure transfer progress, know when a received message is complete,
   and potentially reuse the connection for additional requests.
   
   
=Message Body Length=

1) any respone to a HEAD request: no messaaage body.

2) any successful response to a connect implies that the connection will become a tunnel 
   after the header fields. Client must ignore content-length

3)   a Transfer-Encoding header field is present in a response and
       the chunked transfer coding is not the final encoding, the
       message body length is determined by reading the connection until
       it is closed by the server.  If a Transfer-Encoding header field
       is present in a request and the chunked transfer coding is not
       the final encoding, the message body length cannot be determined
       reliably; the server MUST respond with the 400 (Bad Request)
       status code and then close the connection. Je pige toujuors pas
5) if valid content-length header field is present without transfer-encoding
	its decimal value defines the expected message body length in octets. 
6) if request nessage and none of the above are true, message is missing
7) its decimal value defines the expected message
       body length in octets. 


=Handling incomplete messages=

=Message Parsing Robustness=

its decimal value defines the expected message body length in octets. 
 server that is expecting to receive
   and parse a request-line SHOULD ignore at least one empty line (CRLF)
   received prior to the request-line.
   
When a server listening only for HTTP request messages, or processing
  what appears from the start-line to be an HTTP request message,
  receives a sequence of octets that does not match the HTTP-message
  grammar aside from the robustness exceptions listed above, the server
  SHOULD respond with a 400 (Bad Request) response.
  
=Transfer Codings=

Transfer coding names are used to indicate an encoding transformation
   that has been, can be, or might need to be applied to a payload body
   in order to ensure "safe transport" through the network.  This
   differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred
   
   ...Skipping the content transfer codings types.
   
   
=Message routing=

=Id a target resources=

>most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.



The purpose is a combination of request semantics and a target resource upon which to apply those
   semantics.  A URI reference (Section 2.7) is typically used as an
   identifier for the "target resource", which a user agent would
   resolve to its absolute form in order to obtain the "target URI".
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   
Once the target uri is determined, the client needs to decide whether a network request is neccessary to accomplish the semantics 
and if so where that request is to be directed.

If the request is not satisfied by a cache, then a typical client
   will check its configuration to determine whether a proxy is to be
   used to satisfy the request.  Proxy configuration is implementation-
   dependent, but is often based on URI prefix matching, selective
   authority matching, or both, and the proxy itself is usually
   identified by an "http" or "https" URI.  If a proxy is applicable,
   the client connects inbound by establishing (or reusing) a connection
   to that proxy.
   
=Request Target=
Once inbound connection obtained, client sends an http request message with a request target derived from the target URI.
There are four formats for the request target

	* origin-form most common when making a request directly to the origin server
	* absolute-form request when making a request to a proxy
	* authority-form
	* asterisk-form
	
Importance of host

=Effective request uri=


=Associating a response to a request=
=Message forwarding=
=Via=
=Transformations=
=Connection management=
The http uri scheme indicates a default connection of tcp over IP, with a default tcp port of 80.
Most clients maintain multiple connections in parallel. More than one connection per server endpoint.
Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.

=Connection=

=Establishment=

=Persistence=

  HTTP/1.1 defaults to the use of "persistent connections", allowing
   multiple requests and responses to be carried over a single
   connection.
   
     A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client
   
=Retrying requests=

 Connections can be closed at any time, with or without intention.
   Implementations ought to anticipate the need to recover from
   asynchronous close events.
   
=Pipelining=

A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 4.2.1 of [RFC7231]), but it MUST send the corresponding 
responses in the same order that the requests were received.
Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to
   pipelining because they can be automatically retried after a
   connection failure
   
=Concurrency=

As a result, this specification does not mandate a particular maximum
   number of connections but, instead, encourages clients to be
   conservative when opening multiple connections.
   
Multiple connections are typically used to avoid the "head-of-line
blocking" problem, wherein a request that takes significant 
server-side processing and/or has a large payload blocks subsequent
 requests on the same connection.  However, each connection consumes server resources.  Furthermore, using multiple connections can cause undesirable side effects in congested networks.
 
 Note that a server might reject traffic that it deems abusive or
   characteristic of a denial-of-service attack, such as an excessive
   number of open connections from a single client.
   
=Failures and Timeouts=

Servers will usually have some timeout value beyond which they will
   no longer maintain an inactive connection
    The use of
   persistent connections places no requirements on the length (or
   existence) of this timeout for either the client or the server.
   
    Implementations SHOULD constantly monitor
   open connections for a received closure signal and respond to it as
   appropriate, since prompt closure of both sides of a connection
   enables allocated system resources to be reclaimed.
   
   >   A server SHOULD sustain persistent connections, when possible, and
   allow the underlying transport's flow-control mechanisms to resolve
   temporary overloads, rather than terminate connections with the
   expectation that clients will retry.  The latter technique can
   exacerbate networ k congestion.
   
   =Tear down=
   
	 he Connection header field (Section 6.1) provides a "close"
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.
   
     A server that sends a "close" connection option MUST initiate a close
	 
   of the connection (see below) after it sends the response containing
   "close".  The server MUST NOT process any further requests received
   on that connection.
   
    If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.
   
   =Upgrade=
   
    A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

>>> A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.
   
   =ABNF list extension: #rule=
   
     A construct "#" is defined, similar to "*", for defining
   comma-delimited lists of elements.  The full form is "<n>#<m>element"
   indicating at least <n> and at most <m> elements, each separated by a
   single comma (",") and optional whitespace (OWS
   
   
   For compatibility with legacy list rules, a recipient MUST parse and
   ignore a reasonable number of empty list elements: enough to handle
   common mistakes by senders that merge values, but not so much that
   they could be used as a denial-of-service mechanism.  In other words,
   a recipient MUST accept lists that satisfy the following syntax:

     #element => [ ( "," / element ) *( OWS "," [ OWS element ] ) ]

     1#element => *( "," OWS ) element *( OWS "," [ OWS element ] )


IANA Considerations


.
.
.
.
.

=Security Considerations=

 HTTP relies on the notion of an authoritative response
 Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

Establishing authority can be difficult.

  By their very nature, HTTP intermediaries are men-in-the-middle and,
   thus, represent an opportunity for man-in-the-middle attack
   
   
   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attack
   
=Attacks via protocol element length=

  Because HTTP uses mostly textual, character-delimited fields, parsers
   are often vulnerable to attacks based on sending very long (or very
   slow) streams of data, particularly where an implementation is
   expecting a protocol element with no predefined length.

   A server can reject a message that has a request-target that is too
   long (Section 6.5.12 of [RFC7231]) or a request payload that is too
   large (Section 6.5.11 of [RFC7231])
   
   `Response splitting`
   
   xploits the line-based
   nature of HTTP message framing and the ordered association of
   requests to responses on persistent connections [Klein].  This
   technique can be particularly damaging when the requests pass through
   a shared cache.
   
   an attacker can send encoded data
   within some parameter of the request that is later decoded and echoed
   within any of the response header fields of the response.
   
   If the decoded data looks like the response has ended and another response has begun.
   the response has been split nd the content withtin the apparetn second response is controlled by the attacker
   The attacker can then make any other request on the same persisten connection and trick the recipients into believing taht the second half of the split is an authoritative answer to the second request.
   
     A common defense against response splitting is to filter requests for
   data that looks like encoded CR and LF (e.g., "%0D" and "%0A").
   
   `request smuggling`
   
   xploits
   differences in protocol parsing among various recipients to hide
   additional requests (which might otherwise be blocked or disabled by
   policy) within an apparently harmless request.
   This specification has introduced new requirements on request
   parsing, 
   
    HTTP does not define a specific mechanism for ensuring message
   integrity, instead relying on the error-detection ability of
   underlying transport protocols and the use of length or
   chunk-delimited framing to detect completenes
   
   
RFC 7231
https://tools.ietf.org/html/rfc7231

Target of an http request is called a resource, each resources identified by ann URI.
 One design goal of HTTP is to separate resource identification from
   request semantics, which is made possible by vesting the request
   semantics in the request method (Section 4) and a few
   request-modifying header fields

 In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., "privilege escalation").  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such "content sniffing" when it is used.
   
   
=Content negotiation=

Proactive, server selects the representation based upon the user agent'sstated preferences
Reactive negotiation server provides a list of representations for the user agent to choose from.
Also conditional content, and active content.


	=Proactive negotiaton=
Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   "best guess" to the user agent along with the first response (hoping
   to avoid the round trip delay of a subsequent request if the "best
   guess" is good enough for the user).  In order to improve the
   server's guess, a user agent MAY send request header fields that
   describe its preferences
Disadvantages:
	Server cannot determine what might be best for user.
	User description in every request can be inefficient.
	Complicates the implementation of origin server
	Limits the reusability of responses for shared caching

	=Reactive Negotiation=
Agent driven negotiation, it selects the best repsonse representation.
   Reactive negotiation suffers from the disadvantages of transmitting a
   list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second
   request to obtain an alternate representation. 
   


=Request Methods=

GET
HEAD
POST
PUT
DELETE
CONNECT
OPTIONS
TRACE

All general-purpose servers MUST support the methods GET and HEAD.
   All other methods are OPTIONAL.
   
hen a request method is received
   that is unrecognized or not implemented by an origin server, the
   origin server SHOULD respond with the 501 (Not Implemented) status
   code.  When a request method is received that is known by an origin
   server but not allowed for the target resource, the origin server
   SHOULD respond with the 405 (Method Not Allowed) status code.
   
=Common method properties=
	=Safe methods=
	if read only, if client does not expect a state change on the origin server.
	GET HEAD OPTIONS TRACE are safe
	=Idempotent methods=
	multiple identical requests have the same effect as a single one.
	PUT DELETE and safe request methods are idempotent.
	=Cacheable methods= 
	safe methods that do not depend on a current or authoritative response are defined as cacheable. GET HEAD POST
	majority of CACHE only support GET and HEAD
	
=GET=
requests transfer of a current selected representation.

=HEAD=
  The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).
   ept that the payload header fields
   (Section 3.3) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification
   
=POST=
	requests that the target resource process the representation enclosed 
	in the request according to the resource's own specific semantics.
	
   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   
=PUT=
  The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  
   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response
   If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.
      The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.
   
   
=DELETE=

=CONNECT=

The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security
Most origin servers do not implement Connect


=OPTIONS=

 The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action.
   A
   server MUST generate a Content-Length field with a value of "0" if no
   payload body is to be sent in the response.
   
=TRACE=


=REQUEST HEADER FIELDS=

	* Accept-Charsets
	* Accept-Language
	* Authorization
	* Host
	* Referer
	* User-Agent
	* Content-Language ?
	
=RESPONSE HEADER FIELDS=

	* Allow
	* Content-Length
	* Content-Location
	* Content-Type
	* Date
	* Last-Modified
	* Location
	* Retry-After
	* Server
	* Transfer-Encoding
	* WWW-Authenticate
	* 

	=Controls=
Omitted some of the headers.
 Controls are request header fields that direct specific handling of
   the request.


* Host

The "Host" header field in a request provides the host and port
 information from the target URI, enabling the origin server to
 distinguish among resources while servicing requests for multiple
 host names on a single IP address.
 
	=Content Negotiation=
	
The following request header fields are sent by a user agent to
engage in proactive negotiation of the response content
	

* Accept-Charset
* Accept-Language


	=Authentication Credentials=
* Authorization 

The "Authorization" header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.
   
   =Request Context=
   
* Referer
The "Referer" [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
* User-Agent
  The "User-Agent" header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.
 
 
 
 
=ERROR CODES=
...


=RESPONSE HEADER FIELDS=

=Control Data=

* Date
 The "Date" header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date)

* Location
The "Location" header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference
	 
* Retry-After

Servers send the "Retry-After" header field to indicate how long the
   user agent ought to wait before making a follow-up request.  When
   sent with a 503 (Service Unavailable) response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   
=Validator Header Fields=



Validator header fields convey metadata about the selected
   representation (Section 3).  In responses to safe requests, validator
   fields describe the selected representation chosen by the origin
   server while handling the response.

* Last-Modified


=Authentication [[Challenges]]=

what mechanisms are available for
   the client to provide authentication credentials in future requests.
   
   
* WWW-Authenticate
The "WWW-Authenticate" header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying crede

=Response Context=

 provide more information about
   the target resource for potential use in later requests

* Allow
 The "Allow" header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.
* Server
 The "Server" header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.
 
 
 
=Sockets=

Raw Sockets
Stream Sockets SOCK_STREAM
Datagram Sockets SOCK_DGRAM


  
                       
                       
                       
                       
                       
=Keywords=
Payload
Vesting
[[Content]] negotiation
ABNF
Hop by hop
C10K Problem
IANA registry https://www.iana.org/protocols
OWS=optional whitespac
RWS=required whitespace
BWS=bad whitespace
Sp= single whitespace
MIME= multi purpose internet mail extension
Idemptotent: unchanged in value following multiplication by itself.
 HTTP method is idempotent if an identical request can be made once or several times in a row with the same effect while leaving the server in the same state. In other words, an idempotent method should not have any side-effects (except for keeping statistics)
CRLF injection, Response splitting
OSI model
Out of the band data
Blocking Single-threaded web server
TCP socket
Network Address Translation (NAT)






=Resources=
https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview
https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa
https://eklitzke.org/blocking-io-nonblocking-io-and-epoll
ABNF
https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_form#:~:text=In%20computer%20science%2C%20augmented%20Backus,as%20a%20bidirectional%20communications%20protocol.
C10K Problem
https://en.wikipedia.org/wiki/C10k_problem


https://www.iana.org/protocols


_guid to network programming_
http://beej.us/guide/bgnet/html/

OSI model
https://en.wikipedia.org/wiki/OSI_model

Header Fields for HTTP/1.1
https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#:~:text=14.13%20Content%2DLength,the%20request%20been%20a%20GET.

What are web servers and how do they work.
https://www.youtube.com/watch?v=JhpUch6lWMw

HTTP crash course
https://www.youtube.com/watch?v=0OrmKCB0UrQ

nginx src
https://github.com/nginx/nginx

CGI
http://www.whizkidtech.redprince.net/cgi-bin/tutorial
https://www.garshol.priv.no/download/text/http-tut.html
http://jkorpela.fi/forms/cgic.html



101	switching protocols
200 OK
201 Created
202 Accepted
204 No content
203 Non-Authoritative information
206 Partial Content
214 transformation applied
300 multiple choice
301 moved permanently
303 see other
304 not modified
400 bad request
400 Not acceptable
405 Method not allowed
409 Conflict
411 length required
414 uri too long
414 Unsupported media type
416 range not satisfiable
426 Upgrade required
501 not implemented
502 Bad gateway



=guidelines=


* Parser
* htons?
* get addrinfo workaround
_Also, all the code written before struct addrinfo was invented we packed all this stuff by hand, so you’ll see a lot of IPv4 code out in the wild that does exactly that. You know, in old versions of this guide and so on.)_


struct sockaddr_in ipv4
	sin_family
	sin-port in NBO (network byte order)
	sin_addr can be obtained with inet_addr (4 bytes ip address)
	
struct sockaddr_storage:
parallel structure that can encapsulate ipv6/ipv4 and be casted to the type you [need
Since we are only allowed inet_addr and it is obsolet and doesn't work with IPv6, we can assume that we should only deal with ipv4?

socket gets a file descriptor from what is in addrinfo.
to associate a port to that socket, you need bind

it takes the fd returned by socket and sockaddr
(AI_PASSIVE) tells the program to bind to the IP of the host it's running on


Due to the subject restrictions, we have to use the old way

// !!! THIS IS THE OLD WAY !!!

int sockfd;
struct sockaddr_in my_addr;

sockfd = socket(PF_INET, SOCK_STREAM, 0);

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(MYPORT);     // short, network byte order
my_addr.sin_addr.s_addr = inet_addr("10.12.110.57"); // can be replaced by INADDR_ANY to bind to your local IP address.
see IN6ADDR_ANY_INIT, or sin6_addr field in sockaadr_in6.
	
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

bind(sockfd, (struct sockaddr *)&my_addr, sizeof my_addr);

setsockopt to avoid address already in use

why connect

port forwarding enable on your router








//listen : <number> <end>
//server_name: <string> <end>
//error_pages: <number> * <path> <end>
//client_max_body_size: <number> <end>
//
//index <string> <end>
//root <string> <end>
//autoindex <string> <end>
//upload_store <string> <end>
//limit_except <string>* <end>


union socketIndex
{
	int port;
	std::string server_name;
}


server {
	listen 80;
	server_name localhost;
	location / {
		index tom.html;
		autodinwx tom.html;
		index tom.html;
	}
	location .php {
		index.php
	}
}

server {
	listen 80;
	server_name 192.138;
	location / {
		index wester.html;
	}
	location .php {
		index.php
	}
}

server {
	listen 5000;
}








struct server_config
{
	std::map<std::string, std::string> directives; \\listen, server_name, error_pages, etc..
	
	std::map<std::string, std::map<std::string, std::string>> routes; 
	//key_value: path
	//mapped_type: maps of directives (index, limit_except, root,  autoindex etc..)
}

server 
	listen ip1:80

server 
	listen ip2:80
	
server 
	listen 80
	
server
	listen ip1:80

ip1:80 -> virtualserver1 fd listens
ip1:80 -> virtualserver3 ""
ip1:80 -> virtualserver3 ""
ip1:80 -> virtualserver3 ""
ip2:80 -> virtualserver2
*:80 ->		virtual



class Server
{
	std::vector<VirtualServer> listeners;
	std::map<int, vector<VirtualServer>>
	[[std]]::list<Client>		clients;
	//or map so we can access the client by socket


	std::map<port_n, server_config> configs; //since we can have multiple server listening on the same port
	key_value is port number, and mapped_type is a serverconfig
	parse()
	checkConfig()/
	init() //creating listeners, bind, 
	{
		instantiate virtual servers
		configs[80][0] =
	}
	
	
	
	run() // the server loop
	addClient(Server Socket & listener) // when a new client socket is created
	readRequest(int fd) will find the client corresponding to fd and read its request
	handleRequest(Client &cs); //write, once the full request has been read through receive
		probably some sub functions since we first have to parse the request
		then define a behavior
	std::exception::ServerError()  // to be called like serverError("context: ", strerror(errno))
	void	log();//display info on stdout, or in a file
}
	

Interface Socket
{
	int fd;
}


listen IP:80
listen 80
server_name localhost






VirtualServer:
{
	int fd;
	bool default; 
	std::string ip;
	unsigned int port;
		u_int16 (?)//
	//we can have multiple virtual server for one port, and we need to specify which is the default
	
	//int	port; //use to access corresponding config
	//std::string host;
	//init()// socket, bind, listen
	//close()
	configs
}

Client:
{
	ServerSocket *s; // client send to listener socket, accept returns a client socket
	int			s_fd; //socket
	...
	std::string request;
}


	



--parse config file

* [X]  change sampled in fields
* [ ] sampleLine won't parse server{ into server {, maybe just keep it that way
* [ ] arguments of fields should be vector/list of strings instead of strings
* [ ] make a function to do sample[0] assign sampled[1]
* [ ] add cgi parsing
* [ ] refactor to update the actual config struct
* [X] remove empty string
* [ ] 
* [ ] 


connections have to persistent, so when do we close them? you can test with your simple example
make the example work with the write part
come up with a clear plan:

 if you get a read connection, then iter through your listeners, add a client,
 get its request then continue
 if you get a write connection, that's where you handle the connection: either read the body, or redirect to the appropriate method:
 simple get the resources, or call the cgi

